# Chess Game Coding Standards

This file defines coding standards and best practices for the Chess Game project. These rules help maintain code quality, consistency, and readability across the entire codebase.

## üèóÔ∏è SOLID Principles

Always follow the SOLID principles:

- **Single Responsibility**: Each class/module must have only one responsibility
- **Open/Closed**: Code should be open for extension but closed for modification
- **Liskov Substitution**: Subtypes must be substitutable for their base types
- **Interface Segregation**: Prefer small, specific interfaces over large, general ones
- **Dependency Inversion**: Depend on abstractions, not concrete implementations

## üß© Composition Over Inheritance

- **Prefer composition over inheritance** - Use interfaces and composition to build flexible, maintainable code
- **Use interfaces for contracts** - Define behavior through interfaces rather than class hierarchies
- **Favor delegation** - Compose objects with specific behaviors rather than inheriting from base classes

### ‚úÖ Good Example:

```typescript
// ‚úÖ Composition - pieces implement interface, use utility functions
export class Queen implements IChessPiece {
  constructor(private readonly color: PieceColor) {}

  getValidMoves(position: Position, board: ChessBoard): Position[] {
    return getSlidingMoves(position, QUEEN_DIRECTIONS, board, this.color)
  }

  executeMove(from: Position, to: Position, board: ChessBoard): MoveResult {
    return executeDefaultMove(this, from, to, board) // Delegated behavior
  }
}

// ‚ùå Inheritance hierarchy would be harder to maintain
abstract class ChessPiece {
  abstract getValidMoves(): Position[]
  // Shared logic that may not apply to all pieces
}
```

### ‚úÖ SOLID Example:

```typescript
// Single responsibility - only handles piece creation
export class PieceFactory {
  static createPiece(type: PieceType, color: PieceColor): IChessPiece {
    return match(type)
      .with(PIECE_TYPE.PAWN, () => new Pawn(color))
      .with(PIECE_TYPE.ROOK, () => new Rook(color))
      .exhaustive()
  }
}

// Interface segregation - specific interface
interface GameStateActions {
  resetGame: () => void
  switchPlayer: () => void
}
```

## üéØ TypeScript Best Practices

### Type Safety

- **Never use `any`** - Always use proper typing. If unsure, create a specific interface or use `unknown`
- **No nested types** - Create new types for each level of complexity
- **Avoid inline objects** - Use existing interfaces/types or create new ones locally
- **Minimize type assertions** - Avoid excessive use of `as string`, `as number`, etc. Use Zod schemas for validation and parsing instead
- **Use Zod for validation** - Always use Zod schemas for request validation, query parsing, and type safety
- **No custom parsing utilities** - Use Zod's built-in coercion and transformation instead of manual parsing

### ‚úÖ Good Example:

```typescript
// ‚úÖ Proper typing with interfaces
interface MoveValidationParams {
  piece: IChessPiece
  from: Position
  to: Position
  board: ChessBoard
}

const validateMove = (params: MoveValidationParams): boolean => {
  // Implementation
}

// ‚úÖ Use Zod schemas for validation and parsing
export const PublicRepertoiresQuerySchema = z.object({
  tags: z.string().or(z.array(z.string())).optional().transform(val => {
    if (!val) return undefined
    return Array.isArray(val) ? val : [val]
  }),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  offset: z.coerce.number().int().min(0).default(0)
})

export const RepertoireIdParamSchema = z.object({
  repertoireId: z.uuid("Invalid repertoire ID format")
})

// ‚úÖ Use Zod validation middleware in routes
router.get("/repertoires/:repertoireId",
  validateParams(RepertoireIdParamSchema),
  validateQuery(PublicRepertoiresQuerySchema),
  controller.getRepertoires
)

// ‚úÖ Type-safe controller methods
async getRepertoires(req: Request, res: Response): Promise<void> {
  const { repertoireId } = req.params as RepertoireIdParamDto
  const { tags, limit, offset } = req.query as unknown as PublicRepertoiresQueryDto
  // Zod has already validated and transformed these parameters
}

// ‚ùå Avoid inline objects
const validateMove = (piece: IChessPiece, from: { x: number; y: number }, to: { x: number; y: number }) => {
  // Don't do this
}

// ‚ùå Excessive type casting and manual parsing
const limit = parseInt(req.query.limit as string, 10) // Bad
const tags = req.query.tags as string[] // Bad
const parseQueryParams = { /* custom utilities */ } // Bad - use Zod instead

// ‚ùå Custom validation middleware
export const validateRepertoireId = (req, res, next) => { /* manual validation */ } // Bad
```

## üõ°Ô∏è Validation with Zod

### Zod Best Practices

- **Always use Zod for validation** - Never create custom validation utilities when Zod can handle it
- **Define schemas in validation/schemas.ts** - Keep all validation schemas centralized
- **Use middleware for validation** - Apply `validateParams()`, `validateQuery()`, and `validateBody()` at the route level
- **Leverage Zod transformations** - Use `.transform()` for data normalization and type coercion
- **Export TypeScript types** - Use `z.infer<typeof Schema>` to generate TypeScript types

### ‚úÖ Zod Schema Patterns:

```typescript
// ‚úÖ Parameter validation
export const UserIdParamSchema = z.object({
  userId: z.uuid("Invalid user ID format")
})

// ‚úÖ Query parameter validation with defaults and coercion
export const PaginationQuerySchema = z.object({
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(10),
  search: z.string().optional()
})

// ‚úÖ Complex transformations for array handling
export const TagsQuerySchema = z.object({
  tags: z
    .string()
    .or(z.array(z.string()))
    .optional()
    .transform((val) => {
      if (!val) return undefined
      return Array.isArray(val) ? val : [val]
    })
})

// ‚úÖ Request body validation
export const CreateUserRequestSchema = z.object({
  email: z.string().email("Invalid email format").toLowerCase(),
  username: z
    .string()
    .min(2)
    .max(50)
    .regex(/^[a-zA-Z0-9_-]+$/),
  password: z
    .string()
    .min(8)
    .regex(/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
})

// ‚úÖ Export types for use in controllers
export type UserIdParamDto = z.infer<typeof UserIdParamSchema>
export type PaginationQueryDto = z.infer<typeof PaginationQuerySchema>
export type CreateUserRequestDto = z.infer<typeof CreateUserRequestSchema>
```

### ‚úÖ Route Integration:

```typescript
// ‚úÖ Apply validation middleware at route level
router.get("/users/:userId", validateParams(UserIdParamSchema), validateQuery(PaginationQuerySchema), controller.getUser)

router.post("/users", validateBody(CreateUserRequestSchema), controller.createUser)
```

### ‚úÖ Controller Usage:

```typescript
// ‚úÖ Use validated types directly
async getUser(req: Request, res: Response): Promise<void> {
  const { userId } = req.params as UserIdParamDto
  const { page, limit, search } = req.query as unknown as PaginationQueryDto
  // All parameters are guaranteed to be validated and properly typed
}
```

## üîÑ Control Flow

### Pattern Matching

- **Use ts-pattern** for conditionals with `match...with` syntax
- **Always add `.exhaustive()`** when all cases should be covered

### ‚úÖ Good Example:

```typescript
const getPieceValue = (piece: IChessPiece): number =>
  match(piece.type)
    .with(PIECE_TYPE.PAWN, () => 1)
    .with(PIECE_TYPE.ROOK, () => 5)
    .with(PIECE_TYPE.QUEEN, () => 9)
    .exhaustive()
```

## üßπ Clean Code Principles

### Variable Usage

- **Eliminate redundant variables** - Don't create variables unless they improve readability or are needed multiple times
- **Prefer direct boolean checks** - Use conditions directly instead of storing boolean results
- **Use `const` over `let`** - Always prefer `const` for immutable bindings. Only use `let` when reassignment is truly necessary

### ‚úÖ Good Example:

```typescript
// ‚úÖ Direct usage
if (isPositionEqual(kingPosition, targetPosition)) {
  return true
}

// ‚ùå Redundant variable
const positionsMatch = isPositionEqual(kingPosition, targetPosition)
if (positionsMatch) {
  return true
}

// ‚úÖ Use const for immutable values
const piece = board[position.x][position.y]
const validMoves = getValidMoves(piece, position, board)

// ‚úÖ Use let only when reassignment is needed
let currentPosition = startPosition
for (const move of moves) {
  currentPosition = applyMove(currentPosition, move)
}

// ‚ùå Unnecessary let usage
let piece = board[position.x][position.y] // Should be const
```

### Comments

- **Minimize comments** - Code should be self-explanatory
- **Rewrite before commenting** - If code needs comments, first try to make it clearer
- **Only comment complex behavior** that cannot be simplified

### Function Design

- **Use meaningful, descriptive names** for functions and variables
- **Keep methods short** and easy to understand
- **Single purpose** - each function should do one thing well

## ‚ö° Async Operations

### Async Best Practices

- **Only make methods async** if they perform actual asynchronous operations
- **Use Promise.all** for parallel operations that don't depend on each other

### ‚úÖ Good Example:

```typescript
// ‚úÖ Parallel execution
const [gameState, playerStats, moveHistory] = await Promise.all([
  fetchGameState(gameId),
  fetchPlayerStats(playerId),
  fetchMoveHistory(gameId)
])

// ‚ùå Sequential execution (slower)
const gameState = await fetchGameState(gameId)
const playerStats = await fetchPlayerStats(playerId)
const moveHistory = await fetchMoveHistory(gameId)
```

## üîç Code Reuse

- **Search for existing utilities** before implementing manual solutions
- **Leverage existing libraries** and helper functions in the project
- **Create reusable utilities** when patterns emerge

## üß™ Testing Standards

### Test Structure

- **Use factories** for creating test data when possible
- **Follow Arrange-Act-Assert** pattern with blank lines between sections
- **Write unit tests** for all new classes and functions
- **One describe block** per function/method
- **Call the tested object "subject"**

### ‚úÖ Good Example:

```typescript
describe("PieceFactory", () => {
  describe("createPiece", () => {
    it("should create a white pawn", () => {
      // Arrange
      const pieceType = PIECE_TYPE.PAWN
      const color = PIECE_COLOR.WHITE

      // Act
      const subject = PieceFactory.createPiece(pieceType, color)

      // Assert
      expect(subject.type).toBe(PIECE_TYPE.PAWN)
      expect(subject.color).toBe(PIECE_COLOR.WHITE)
    })
  })
})
```

## üìÅ File Organization

- **Index files** should only export, not contain logic
- **Co-locate related files** in feature directories
- **Consistent naming** - use PascalCase for components, camelCase for utilities
- **Type definitions** in separate `.types.ts` files when shared

## üé® Code Style

- **Consistent formatting** - rely on Prettier and ESLint
- **Meaningful variable names** that explain intent
- **Avoid abbreviations** unless they're well-known (e.g., `id`, `url`)
- **Use const assertions** for readonly data (`as const`)

## üåà CSS Color Management

- **Use CSS custom properties for colors** - Add all colors to the `:root` variables in `src/index.scss`
- **Never use hardcoded color values** - Always reference CSS variables for consistency and maintainability
- **Follow naming convention** - Use `--color-[palette]-[shade]` format (e.g., `--color-emerald-500`)

### ‚úÖ Good Example:

```scss
// ‚úÖ Add colors to :root in src/index.scss
:root {
  --color-emerald-500: #10b981;
  --color-emerald-600: #059669;
  --color-chess-light: #f0d9b5;
  --color-chess-dark: #b58863;
}

// ‚úÖ Use variables in component styles
.chess-square {
  background-color: var(--color-chess-light);
  border: 1px solid var(--color-emerald-500);

  &--dark {
    background-color: var(--color-chess-dark);
  }

  &:hover {
    border-color: var(--color-emerald-600);
  }
}

// ‚ùå Hardcoded colors
.chess-square {
  background-color: #f0d9b5; // Should use CSS variable
  border: 1px solid #10b981; // Should use CSS variable
}
```

## üîß Backend-Specific Standards

### Interface Naming Conventions

- **Backend interfaces** - Use `*Interface` naming pattern (e.g., `AuthServiceInterface`, `GameServiceInterface`)
- **Frontend interfaces** - Use `I*` naming pattern (e.g., `IAuthService`, `IGameService`)
- **Separate interface files** - Backend interfaces must be defined in separate `*.interface.ts` files (e.g., `authService.interface.ts`)
- **Interface imports** - Always import interfaces from their dedicated interface files, not from service files

### Service Layer Architecture

These rules apply specifically to backend service classes to ensure consistent dependency injection and clear separation of concerns:

- **Interface definition** - Every service class must have an interface defined in a separate `*.interface.ts` file and used everywhere possible
- **Constructor injection** - All dependencies must be injected via the constructor and marked as `private readonly`
- **Static builder pattern** - Each service should have a static `build()` method for dependency instantiation
- **Builder placement** - The static `build()` method must always be the last function in the class
- **Method organization** - Always place all private functions below all interface and public functions in service classes
- **NO require() in build methods** - Always use ES6 imports at the top of the file, never use `require()` inside build methods
- **Import dependencies properly** - All service dependencies must be imported using ES6 import syntax

### ‚úÖ Good Example:

```typescript
// ‚úÖ Backend service with proper structure
// gameService.interface.ts
export interface GameServiceInterface {
  createGame(): Promise<Game>
  getGame(id: string): Promise<Game | null>
  updateGame(id: string, updates: Partial<Game>): Promise<Game>
}

// GameService.ts
import { GameServiceInterface } from "./gameService.interface"
import { GameRepository } from "./GameRepository"
import { IdGenerator } from "./IdGenerator"
import { Logger } from "./Logger"

export class GameService implements GameServiceInterface {
  constructor(
    private readonly gameRepository: GameRepositoryInterface,
    private readonly idGenerator: IdGeneratorInterface,
    private readonly logger: LoggerInterface
  ) {}

  // Public interface methods
  async createGame(): Promise<Game> {
    const id = this.generateGameId()
    const game = this.createInitialGameState(id)
    return await this.gameRepository.save(game)
  }

  async getGame(id: string): Promise<Game | null> {
    return await this.gameRepository.findById(id)
  }

  async updateGame(id: string, updates: Partial<Game>): Promise<Game> {
    const game = await this.getGame(id)
    if (!game) {
      throw new Error(`Game with id ${id} not found`)
    }

    const updatedGame = { ...game, ...updates }
    return await this.gameRepository.save(updatedGame)
  }

  // Private methods below public methods
  private generateGameId(): string {
    return this.idGenerator.generate()
  }

  private createInitialGameState(id: string): Game {
    return {
      id,
      status: "active",
      board: this.createInitialBoard(),
      currentPlayer: "white"
    }
  }

  private createInitialBoard(): ChessBoard {
    // Implementation details
  }

  // Static build method - always last with proper ES6 imports
  static build(): GameService {
    return new GameService(GameRepository.build(), IdGenerator.build(), Logger.build())
  }
}

// ‚ùå Bad example - no interface, no dependency injection, require() usage
export class GameService {
  async createGame(): Promise<Game> {
    const gameRepository = new GameRepository() // Direct instantiation
    const id = Math.random().toString() // No abstraction
    // ...
  }

  // ‚ùå Never use require() in build methods
  static build(): GameService {
    const { GameRepository } = require("./GameRepository") // BAD!
    const { IdGenerator } = require("./IdGenerator") // BAD!
    return new GameService(GameRepository.build(), IdGenerator.build())
  }
}
```

### Dependency Usage

- **Use interfaces everywhere** - Controllers, other services, and tests should depend on the interface, not the concrete class
- **Consistent naming** - Backend interface names should end with `Interface` (e.g., `GameServiceInterface`)
- **Builder chaining** - Use the static `build()` methods to create service instances with their dependencies

### ‚úÖ Controller Integration Example:

```typescript
// ‚úÖ Controller uses interface
import { GameServiceInterface } from "@/services/gameService.interface"

export class GameController {
  constructor(private readonly gameService: GameServiceInterface) {}

  async createGame(req: Request, res: Response): Promise<void> {
    const game = await this.gameService.createGame()
    res.json(game)
  }

  static build(): GameController {
    return new GameController(GameService.build())
  }
}
```

---

_These rules help maintain high code quality and consistency across the Chess Game project. When in doubt, prioritize readability and maintainability._
